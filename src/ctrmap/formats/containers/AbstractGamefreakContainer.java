package ctrmap.formats.containers;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

import ctrmap.LittleEndianDataInputStream;
import ctrmap.LittleEndianDataOutputStream;
import ctrmap.Utils;
import ctrmap.Workspace;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Extractor for the generic containers used in 3DS Pokemon games (6 and 7).
 * Generally, those files are generated by gflib_cpp/tools/binlinder.rb,
 * official name is unknown. Often also called Mini packs.
 */
public abstract class AbstractGamefreakContainer {

	private File f;
	public int len;
	private int[] offsets;
	
	public abstract short getHeader();

	public AbstractGamefreakContainer(File f) {
		if (f != null) {
			this.f = f;
			verify();
		} else {
			System.err.println("Unable to open file. Expect a crash soon.");
		}
	}

	public boolean verify() {
		try {
			LittleEndianDataInputStream dis = new LittleEndianDataInputStream(new FileInputStream(f));
			if (dis.read2Bytes() != getHeader()) {
				System.err.println("GfContainer header mismatch!");
				System.out.println("Error verifying file " + f.getAbsolutePath());
			}
			len = dis.readShort();
			offsets = new int[len + 1];
			for (int i = 0; i < len + 1; i++) {
				offsets[i] = dis.readInt();
			}
			dis.close();
			return true;
		} catch (IOException e) {
			e.printStackTrace();
			System.out.println("An IOException occured while reading " + f.getName());
			return false;
		}
	}

	public File getOriginFile() {
		return f;
	}

	public int getOffset(int fileNum) {
		return offsets[fileNum];
	}

	public byte[] getFile(int fileNum) {
		try {
			LittleEndianDataInputStream dis = new LittleEndianDataInputStream(new FileInputStream(f));
			dis.skip(offsets[fileNum]);
			byte[] b = new byte[offsets[fileNum + 1] - offsets[fileNum]];
			dis.read(b);
			dis.close();
			return b;
		} catch (IOException e) {
			Logger.getLogger(AbstractGamefreakContainer.class.getName()).log(Level.SEVERE, null, e);
			return null;
		}
	}
	
	public File getIOFile(int fileNum){
		try {
			byte[] b = getFile(fileNum);
			File out = new File(Workspace.temp + "/agfc_extract_" + UUID.randomUUID().toString());
			OutputStream os = new FileOutputStream(out);
			os.write(b);
			os.close();
			return out;
		} catch (IOException ex) {
			return null;
		}
	}

	public boolean checkStoreStatus(int num, byte[] data) {
		return !Arrays.equals(data, getFile(num));
	}
	
	public abstract ContentType getDefaultContentType(int index);
	
	public abstract boolean getIsPadded();
	
	public void storeFile(int num, byte[] data) {
		byte[] paddedData;
		if (getIsPadded()){
			byte[] padding = Utils.getPadding(getOffset(num), data.length);
			paddedData = new byte[data.length + padding.length];
			System.arraycopy(data, 0, paddedData, 0, data.length);
			System.arraycopy(padding, 0, paddedData, data.length, padding.length);
		}
		else {
			paddedData = data;
		}
		if (!checkStoreStatus(num, paddedData)){
			return;
		}
		try {
			int pos = 0;
			LittleEndianDataInputStream dis = new LittleEndianDataInputStream(new FileInputStream(f));
			byte[] b = new byte[dis.available()];
			dis.read(b);
			dis.close();
			//calculate new offsets
			int change = paddedData.length - (offsets[num + 1] - offsets[num]);
			for (int i = num + 1; i < len + 1; i++) {
				offsets[i] += change;
			}
			LittleEndianDataOutputStream out = new LittleEndianDataOutputStream(new FileOutputStream(f));
			out.write2Bytes(getHeader());
			out.writeShort((short) len);
			pos += 4;
			for (int i = 0; i < offsets.length; i++) {
				out.writeInt(offsets[i]);
				pos += 4;
			}
			while (pos < offsets[0]) {
				out.write(0);
				pos++;
			}
			int firstlen = offsets[num] - offsets[0];
			if (firstlen > 0) {
				byte[] bytesbefore = new byte[firstlen];
				System.arraycopy(b, offsets[0], bytesbefore, 0, firstlen);
				out.write(bytesbefore);
			}
			out.write(paddedData);
			int secondlen = offsets[len] - offsets[num + 1];
			if (secondlen > 0) {
				byte[] bytesafter = new byte[secondlen];
				System.arraycopy(b, offsets[num + 1] - change, bytesafter, 0, secondlen);
				out.write(bytesafter);
			}
			out.flush();
			out.close();
			Workspace.addPersist(getOriginFile());
		} catch (IOException e) {
			e.printStackTrace();
			System.out.println("An IOException occured while reading " + f.getName());
		}
	}
	
	public void storeFile(int num, File f){
		try {
			InputStream in = new FileInputStream(f);
			byte[] b = new byte[in.available()];
			in.read(b);
			storeFile(num, b);
			in.close();
		} catch (IOException ex) {
			Logger.getLogger(AbstractGamefreakContainer.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
}
